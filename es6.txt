# 3.0 es6基础知识点
### 一、箭头函数
1、箭头函数体内部没有上下文
2、箭头函数体不能用于构造函数（没有上下文）
3、不接受arguments对象（用解构来获取入参）
4、不能用于Generator函数构建

### 二、变量申明
#### 1、let
1. 具备块级作用域（var不具备块级作用域是设计缺陷）
2. window不能直接访问let变量
3. 循环声明（for(let x)）都会重新分配内存
4. 变量提升（暂时性死区TDZ机制）和重复声明会报错
   
#### 2、const
在let基础上多了个常量限制


### 三、解构赋值
```javaScript
  let [a, [b], d] = [1, [2, 3], 4];
  //a: 1, b: 2, c: 4

  let [a, [...b], d] = [1, [2, 3], 4];
  //a: 1, b: [2, 3], d: 4
```
解构赋值要求右边的表达式上可遍历的类型（具备Iterator的数据结构都可），并且能转为对象，否则报错

1. 数组的解构赋值基于索引，对象的解构赋值基于key
2. 字符串的解构赋值类似数组
3. 函数参数的解构赋值

### 四、数组和对象的扩展运算符
  es2017引入数组拓展运算符`...`，es2018引入来对象的`...`
1. rest 参数的逆运算（数组或者对象转为序列）
2. 可跟接逻辑表达式（逻辑运算或三目运算）
3. 可用于复制、合并、解构赋值和构建Iterator
```javaScript

  //解构赋值
  let [obj, arr, ...rest] = [{a:1}, [1], '1', '2'];  //rest: ['1', '2']
  //复制
  let cObj = {...obj}
  //合并
  let nObj = {...obj, ...{b:1}}
  //构建Iterator
  Number.prototype[Symbol.iterator] = function *() {
    let i = 0;
    let num = this.valueOf();
    while (i < num) {
      yield i++;
    }
  }
  console.log([...5]) // [0, 1, 2, 3, 4]
  
```
### 编程风格
```javaScript

  /**
  * 1. const > let > var
  */
  const { a, b, c } = { c: 1, b: 2, a: 3, }

  /**
  * 2. 字符串均由单引号和反引号表示
  */
  console.log(`b的值是${b}`);

  /**
  * 3. 优先对象的解构赋值
  * 利于调整参数和默认初始值
  */
  const getFullName = ({ fir = 'bin', sec = 'wen' } = {}) => fir + sec;
  getFullName() // bingwen
  getFullName({ fir: 'mao', sec: 'yu' }) // maoyu
  
```

### 五、Symbol类型和Set、Map数据结构
js数据类型有：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）、Symbol
Symbol：独一无二的值（不是很感兴趣）

Set
1. set不存在重复值
2. set.size、set.add、set.has、set.delete、set.clear
3. set中NaN等同于NaN

Map
1. 